---
layout: post
title: SQHell â€” Tryhackme (Writeup)
date: 2025-08-20
categories: [TRYHACKME-WRITEUPS]
tag: [cybersecurity, writeups,TRYHACKME]
---

URL: [SqHell](https://tryhackme.com/room/sqhell)

Writeup By : [BlueCoder](https://tryhackme.com/p/blueCoder) and [CyberLabyrinthX](https://cyberlabyrinthx.medium.com/)

![photo](/images/TryHackme-SQHELL/sqhell.png)

SQHell is a SQL injection room in TryHackMe that you can join to test your SQL injection skills.

## 1. Enumeration

First things first, we perform a nmap scan and see all the open ports.

![photo2](/images/TryHackme-SQHELL/Enumeration.png)

We see that there's 4 open ports:

22 for SSH

80 for a HTTP site

4420 for NVM Express over Fabrics storage access

and port 5226 for HP Status for HP network devices

Here, we are mostly just interested in the website for now.

So let's see whats going on in the website.

## 2. Into the website

![photo3](/images/TryHackme-SQHELL/intowebsite.png)

## First Flag

The website looks simple and has only two posts, a login, a register page and terms and conditions.

![photo4](/images/TryHackme-SQHELL/register_page.png)

We get into the login page and try a few sql payloads on the username.

`OR '1'='1` does not seem to work.

However,

`' OR '1'='1' -- - ` with comments in the end does work and gives us our first flag.

## Second flag

Next we go to the register page, and we see that the register button does not really work since
registrations are not open anymore.


![photo5](/images/TryHackme-SQHELL/no-longer.png)

However, you can see that there's an API endpoint that's checking if the username is available or not.

You can intercept this API request using burpsuite and send it to the repeater.

![photo6](/images/TryHackme-SQHELL/BURP.png)

And copy paste everything to a file ->`request.txt` for example.

We can then enumerate all the databases, tables and dump any interesting table using `sqlmap` .

```console

sqlmap -r request.txt --dbs --dbms=mysql -p username
```

Here, we are giving the copied request as request.txt, specifying that the database is mysql and hinting
that the parameter `username` is sql-injectable.

Once we get the database name, which is gonna look like `sqhell_x` we list the tables inside it:

```console

sqlmap -r request.txt --dbms=mysql -p username -D sqhell_x --tables
```

And finally we dump the flag table for the flag.

```console

sqlmap -r request.txt --dbms=mysql -p username -D sqhell_x -T flag --dump
```

## Third Flag

The next page we visit is the posts page.

![photo7](/images/TryHackme-SQHELL/posts.png)

We see that the posts page also has an id parameter.

![photo8](/images/TryHackme-SQHELL/id-param.png)

Just like the previous one, we save the request in a file and let sql map do the job. The process is identical
to the previous one, you just have to find a different database and `maybe` a different table.

## Fourth Flag

The fourth flag is a bit tricky one.
First we go to the Terms and Conditions page. Because we are simply assuming that every page is
vulnerable at this point.

However, the terms and conditions page does not seem to have any parameter. But if you read the terms,
there's a hint.

![photo9](/images/TryHackme-SQHELL/hint.png)

The third term says that the site logs your IP address, and while this may not sound like a vector, but
HTTP has a header that allows you to fake your IP address (its intended to record the real IP in case
you're using a proxy.)

The header is:

`X-Forwarded-For: xxx.xxx.xxx.xxx`

![photo10](/images/TryHackme-SQHELL/header-burp.png)

So just like the previous flags, we copy-paste the request in a text file. Except, this time we also give
sqlmap a headers parameter.


```console

sqlmap -r requests.txt --headers="X-Forwarded-For:127.0.0.1" -p "X-Forwarded-For" --
dbms=mysql -dbs
```

This one will actually take a while because its a blind timing attack. So maybe get a coffee until then.

## The final flag

The final flag we are looking for is probably in the only page we have left. The users page.

![photo11](/images/TryHackme-SQHELL/final-flag.png)

However, this one is a lot tricky, so stick with me !
Now, if you've tried the previous methods we used for other flags, you will get the sqhell_4 db and the
table and be able to dump it.

![photo12](/images/TryHackme-SQHELL/sqlmap-users.png)

But there is no flag !

If you see the hint in TryHackMe, you see a quote

"Well, dreams, they feel real while we're in them right?"

which if you google search will take you to a movie called

"Inception" which is about having dreams in your dreams.

Which is what this challenge is about - A nested sql injection !

Imagine this is the query that the server backend is using to fetch the data from the mysql server:

```console

$user = SELECT * FROM users where id="id_parameter_you_provide";

$posts = SELECT * FROM posts WHERE user_id =$user[id];

```
`â„¹` The above code is neither syntactically correct, nor does it represent what backend code look like.

However, you can see the logic. The id you provide using the `?id=1` query parameter, is actually not
directly used to fetch user posts made by a user.

First, the id is passed to a database connection and a user row is fetched, which has a column called "id"
that has the user id.


Now, this user id is passed to another database connection, where its used to fetch a table of posts made
by the user. And the reason we're not able to directly get the flag is due to the fact that the two queries
connect to two different databases, and the flag table is most likely in the second database which is
accessed by the second query.

1. So, first we need to determine how many columns are there in the first table that has the users. And
we already know its 3.

2. Next, we need to replace the entire column returned by the first query, such the the first value (id) is
used by the second query to retrieve the flag.


```console

0 UNION SELECT "1 UNION SELECT 1,flag, 3, 4 FROM flag -- -", 1,2 FROM users
```

Here, the backend uses the values on the right side as the user data (id, username, password).

And it assumes that the first value is id.

```console

1 UNION SELECT 1,flag, 3, 4 FROM flag -- -
```

And it uses the id to fetch posts from another database. And we're manipulating this id to fetch our flag
instead.

`[Don't forget to URL-encode everything before sending.]`

![photo13](/images/TryHackme-SQHELL/flag-end.png)

and with that, we get our final flag.
ðŸ¥³ðŸŽ‰ðŸŽ‰ðŸŽ‰
